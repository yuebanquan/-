# 状态设计模式

> 博客地址：https://yuebanquan.github.io/2019/06/06/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/

## 一．应用场景与案例描述

​		我们经常在课余时间玩游戏以放松身心，缓解压力。在很多游戏中英雄根据不同的体力值，可以做出不同的动作来面对敌人。

​		英雄可以进行休息、防御、普通攻击、技能攻击。而消耗或恢复的体力值是不同的，例如：

1. 休息：恢复体力值至最大，体力值为最大时无需休息；
2. 防御：消耗10点体力值，没有体力值无法进行防御；
3.  普通攻击：消耗15点体力值，没有体力值无法进行普通攻击；
4.  技能攻击：消耗20点体力值，没有体力值无法进行技能攻击；



## 二．案例分析与解决问题

​		倘若我们将这些操作逻辑都写在同一个类——英雄类中作为英雄的方法的话，会出现以下问题：

1. 后期如果操作逻辑（如消耗的体力值变化）有所改变就需要修改整个英雄类；
2. 后期如果要增加操作（如增加魔法攻击）的话需要修改整个英雄类；
3. 只能堆砌非常多的if—else if—else，代码不好维护，可读性很差；



​		所以我决定使用状态模式以解决这个问题。状态模式在本情景下所体现出来的优点：

1. 使用一个类封装对象的一种状态（操作），很容易添加新的状态（操作）；
2. 在状态模式中，环境（Context）——英雄类（Hero）中不必出现大量的条件判断语句。环境（Context）实例所呈现的状态变得更加清晰、容易理解；
3. 使用状态模式可以让用户程序很方便地切换环境（Context）——英雄类（Hero）实例的状态（操作）；
4. 使用状态模式不会让环境（Context）——英雄类（Hero）的实例中出现内部状态不一致的情况；
5. 当状态对象没有实例变量时，环境（Context）——英雄类（Hero）的各个实例可以共享一个状态对象；

 

我将英雄的操作抽象为状态，四种操作对应着四种不同的具体状态： 

* RestState（休息状态）
* DefenseState（防御状态）
* NormalAttackState（普通攻击状态）
* SkillAttackState（技能攻击状态）



## 三．各个角色描述与UML图示

#### 角色描述：

1. 环境（Context）：Hero类
2.  抽象状态（State）：State抽象类
3. 具体状态（Concrete State）：RestState、DefenseState、NormalAttackState和SkillAttackState类

#### UML图
![UML](https://yuebanquan.github.io/2019/06/06/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8FUML.jpg)



## 五．运行效果

#### 1. 生成apk
![生成apk](https://yuebanquan.github.io/2019/06/06/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/apk.jpg)
